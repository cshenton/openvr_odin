package openvr

import vk "vendor:vulkan"
import D3D11 "vendor:directx/d3d11"
import D3D12 "vendor:directx/d3d12"

ISystem :: struct {
	GetRecommendedRenderTargetSize: proc "stdcall" (pnWidth: ^u32, pnHeight: ^u32),
	GetProjectionMatrix: proc "stdcall" (eEye: Eye, fNearZ: f32, fFarZ: f32) -> HmdMatrix44,
	GetProjectionRaw: proc "stdcall" (eEye: Eye, pfLeft: ^f32, pfRight: ^f32, pfTop: ^f32, pfBottom: ^f32),
	ComputeDistortion: proc "stdcall" (eEye: Eye, fU: f32, fV: f32, pDistortionCoordinates: ^DistortionCoordinates) -> bool,
	GetEyeToHeadTransform: proc "stdcall" (eEye: Eye) -> HmdMatrix34,
	GetTimeSinceLastVsync: proc "stdcall" (pfSecondsSinceLastVsync: ^f32, pulFrameCounter: ^u64) -> bool,
	GetD3D9AdapterIndex: proc "stdcall" () -> i32,
	GetDXGIOutputInfo: proc "stdcall" (pnAdapterIndex: ^i32),
	GetOutputDevice: proc "stdcall" (pnDevice: ^u64, textureType: TextureType, pInstance: vk.Instance),
	IsDisplayOnDesktop: proc "stdcall" () -> bool,
	SetDisplayVisibility: proc "stdcall" (bIsVisibleOnDesktop: bool) -> bool,
	GetDeviceToAbsoluteTrackingPose: proc "stdcall" (eOrigin: TrackingUniverseOrigin, fPredictedSecondsToPhotonsFromNow: f32, pTrackedDevicePoseArray: ^TrackedDevicePose, unTrackedDevicePoseArrayCount: u32),
	GetSeatedZeroPoseToStandingAbsoluteTrackingPose: proc "stdcall" () -> HmdMatrix34,
	GetRawZeroPoseToStandingAbsoluteTrackingPose: proc "stdcall" () -> HmdMatrix34,
	GetSortedTrackedDeviceIndicesOfClass: proc "stdcall" (eTrackedDeviceClass: TrackedDeviceClass, punTrackedDeviceIndexArray: ^TrackedDeviceIndex, unTrackedDeviceIndexArrayCount: u32, unRelativeToTrackedDeviceIndex: TrackedDeviceIndex) -> u32,
	GetTrackedDeviceActivityLevel: proc "stdcall" (unDeviceId: TrackedDeviceIndex) -> DeviceActivityLevel,
	ApplyTransform: proc "stdcall" (pOutputPose: ^TrackedDevicePose, pTrackedDevicePose: ^TrackedDevicePose, pTransform: ^HmdMatrix34),
	GetTrackedDeviceIndexForControllerRole: proc "stdcall" (unDeviceType: TrackedControllerRole) -> TrackedDeviceIndex,
	GetControllerRoleForTrackedDeviceIndex: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex) -> TrackedControllerRole,
	GetTrackedDeviceClass: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex) -> TrackedDeviceClass,
	IsTrackedDeviceConnected: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex) -> bool,
	GetBoolTrackedDeviceProperty: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex, prop: TrackedDeviceProperty, pError: ^TrackedPropertyError) -> bool,
	GetFloatTrackedDeviceProperty: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex, prop: TrackedDeviceProperty, pError: ^TrackedPropertyError) -> f32,
	GetInt32TrackedDeviceProperty: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex, prop: TrackedDeviceProperty, pError: ^TrackedPropertyError) -> i32,
	GetUint64TrackedDeviceProperty: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex, prop: TrackedDeviceProperty, pError: ^TrackedPropertyError) -> u64,
	GetMatrix34TrackedDeviceProperty: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex, prop: TrackedDeviceProperty, pError: ^TrackedPropertyError) -> HmdMatrix34,
	GetArrayTrackedDeviceProperty: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex, prop: TrackedDeviceProperty, propType: PropertyTypeTag, pBuffer: rawptr, unBufferSize: u32, pError: ^TrackedPropertyError) -> u32,
	GetStringTrackedDeviceProperty: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex, prop: TrackedDeviceProperty, pchValue: cstring, unBufferSize: u32, pError: ^TrackedPropertyError) -> u32,
	GetPropErrorNameFromEnum: proc "stdcall" (error: TrackedPropertyError) -> cstring,
	PollNextEvent: proc "stdcall" (pEvent: ^Event, uncbVREvent: u32) -> bool,
	PollNextEventWithPose: proc "stdcall" (eOrigin: TrackingUniverseOrigin, pEvent: ^Event, uncbVREvent: u32, pTrackedDevicePose: ^TrackedDevicePose) -> bool,
	GetEventTypeNameFromEnum: proc "stdcall" (eType: EventType) -> cstring,
	GetHiddenAreaMesh: proc "stdcall" (eEye: Eye, type: HiddenAreaMeshType) -> HiddenAreaMesh,
	GetControllerState: proc "stdcall" (unControllerDeviceIndex: TrackedDeviceIndex, pControllerState: ^ControllerState, unControllerStateSize: u32) -> bool,
	GetControllerStateWithPose: proc "stdcall" (eOrigin: TrackingUniverseOrigin, unControllerDeviceIndex: TrackedDeviceIndex, pControllerState: ^ControllerState, unControllerStateSize: u32, pTrackedDevicePose: ^TrackedDevicePose) -> bool,
	TriggerHapticPulse: proc "stdcall" (unControllerDeviceIndex: TrackedDeviceIndex, unAxisId: u32, usDurationMicroSec: u16),
	GetButtonIdNameFromEnum: proc "stdcall" (eButtonId: ButtonId) -> cstring,
	GetControllerAxisTypeNameFromEnum: proc "stdcall" (eAxisType: ControllerAxisType) -> cstring,
	IsInputAvailable: proc "stdcall" () -> bool,
	IsSteamVRDrawingControllers: proc "stdcall" () -> bool,
	ShouldApplicationPause: proc "stdcall" () -> bool,
	ShouldApplicationReduceRenderingWork: proc "stdcall" () -> bool,
	PerformFirmwareUpdate: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex) -> FirmwareError,
	AcknowledgeQuit_Exiting: proc "stdcall" (),
	GetAppContainerFilePaths: proc "stdcall" (pchBuffer: cstring, unBufferSize: u32) -> u32,
	GetRuntimeVersion: proc "stdcall" () -> cstring,
}

IChaperone :: struct {
	GetCalibrationState: proc "stdcall" () -> ChaperoneCalibrationState,
	GetPlayAreaSize: proc "stdcall" (pSizeX: ^f32, pSizeZ: ^f32) -> bool,
	GetPlayAreaRect: proc "stdcall" (rect: ^HmdQuad) -> bool,
	ReloadInfo: proc "stdcall" (),
	SetSceneColor: proc "stdcall" (color: HmdColor),
	GetBoundsColor: proc "stdcall" (pOutputColorArray: ^HmdColor, nNumOutputColors: int, flCollisionBoundsFadeDistance: f32, pOutputCameraColor: ^HmdColor),
	AreBoundsVisible: proc "stdcall" () -> bool,
	ForceBoundsVisible: proc "stdcall" (bForce: bool),
	ResetZeroPose: proc "stdcall" (eTrackingUniverseOrigin: TrackingUniverseOrigin),
}

IChaperoneSetup :: struct {
	CommitWorkingCopy: proc "stdcall" (configFile: ChaperoneConfigFile) -> bool,
	RevertWorkingCopy: proc "stdcall" (),
	GetWorkingPlayAreaSize: proc "stdcall" (pSizeX: ^f32, pSizeZ: ^f32) -> bool,
	GetWorkingPlayAreaRect: proc "stdcall" (rect: ^HmdQuad) -> bool,
	GetWorkingCollisionBoundsInfo: proc "stdcall" (pQuadsBuffer: ^HmdQuad, punQuadsCount: ^u32) -> bool,
	GetLiveCollisionBoundsInfo: proc "stdcall" (pQuadsBuffer: ^HmdQuad, punQuadsCount: ^u32) -> bool,
	GetWorkingSeatedZeroPoseToRawTrackingPose: proc "stdcall" (pmatSeatedZeroPoseToRawTrackingPose: ^HmdMatrix34) -> bool,
	GetWorkingStandingZeroPoseToRawTrackingPose: proc "stdcall" (pmatStandingZeroPoseToRawTrackingPose: ^HmdMatrix34) -> bool,
	SetWorkingPlayAreaSize: proc "stdcall" (sizeX: f32, sizeZ: f32),
	SetWorkingCollisionBoundsInfo: proc "stdcall" (pQuadsBuffer: ^HmdQuad, unQuadsCount: u32),
	SetWorkingPerimeter: proc "stdcall" (pPointBuffer: ^HmdVector2, unPointCount: u32),
	SetWorkingSeatedZeroPoseToRawTrackingPose: proc "stdcall" (pMatSeatedZeroPoseToRawTrackingPose: ^HmdMatrix34),
	SetWorkingStandingZeroPoseToRawTrackingPose: proc "stdcall" (pMatStandingZeroPoseToRawTrackingPose: ^HmdMatrix34),
	ReloadFromDisk: proc "stdcall" (configFile: ChaperoneConfigFile),
	GetLiveSeatedZeroPoseToRawTrackingPose: proc "stdcall" (pmatSeatedZeroPoseToRawTrackingPose: ^HmdMatrix34) -> bool,
	ExportLiveToBuffer: proc "stdcall" (pBuffer: cstring, pnBufferLength: ^u32) -> bool,
	ImportFromBufferToWorking: proc "stdcall" (pBuffer: cstring, nImportFlags: u32) -> bool,
	ShowWorkingSetPreview: proc "stdcall" (),
	HideWorkingSetPreview: proc "stdcall" (),
	RoomSetupStarting: proc "stdcall" (),
}

ICompositor :: struct {
	SetTrackingSpace: proc "stdcall" (eOrigin: TrackingUniverseOrigin),
	GetTrackingSpace: proc "stdcall" () -> TrackingUniverseOrigin,
	WaitGetPoses: proc "stdcall" (pRenderPoseArray: ^TrackedDevicePose, unRenderPoseArrayCount: u32, pGamePoseArray: ^TrackedDevicePose, unGamePoseArrayCount: u32) -> CompositorError,
	GetLastPoses: proc "stdcall" (pRenderPoseArray: ^TrackedDevicePose, unRenderPoseArrayCount: u32, pGamePoseArray: ^TrackedDevicePose, unGamePoseArrayCount: u32) -> CompositorError,
	GetLastPoseForTrackedDeviceIndex: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex, pOutputPose: ^TrackedDevicePose, pOutputGamePose: ^TrackedDevicePose) -> CompositorError,
	Submit: proc "stdcall" (eEye: Eye, pTexture: ^Texture, pBounds: ^TextureBounds, nSubmitFlags: SubmitFlags) -> CompositorError,
	ClearLastSubmittedFrame: proc "stdcall" (),
	PostPresentHandoff: proc "stdcall" (),
	GetFrameTiming: proc "stdcall" (pTiming: ^Compositor_FrameTiming, unFramesAgo: u32) -> bool,
	GetFrameTimings: proc "stdcall" (pTiming: ^Compositor_FrameTiming, nFrames: u32) -> u32,
	GetFrameTimeRemaining: proc "stdcall" () -> f32,
	GetCumulativeStats: proc "stdcall" (pStats: ^Compositor_CumulativeStats, nStatsSizeInBytes: u32),
	FadeToColor: proc "stdcall" (fSeconds: f32, fRed: f32, fGreen: f32, fBlue: f32, fAlpha: f32, bBackground: bool),
	GetCurrentFadeColor: proc "stdcall" (bBackground: bool) -> HmdColor,
	FadeGrid: proc "stdcall" (fSeconds: f32, bFadeGridIn: bool),
	GetCurrentGridAlpha: proc "stdcall" () -> f32,
	SetSkyboxOverride: proc "stdcall" (pTextures: ^Texture, unTextureCount: u32) -> CompositorError,
	ClearSkyboxOverride: proc "stdcall" (),
	CompositorBringToFront: proc "stdcall" (),
	CompositorGoToBack: proc "stdcall" (),
	CompositorQuit: proc "stdcall" (),
	IsFullscreen: proc "stdcall" () -> bool,
	GetCurrentSceneFocusProcess: proc "stdcall" () -> u32,
	GetLastFrameRenderer: proc "stdcall" () -> u32,
	CanRenderScene: proc "stdcall" () -> bool,
	ShowMirrorWindow: proc "stdcall" (),
	HideMirrorWindow: proc "stdcall" (),
	IsMirrorWindowVisible: proc "stdcall" () -> bool,
	CompositorDumpImages: proc "stdcall" (),
	ShouldAppRenderWithLowResources: proc "stdcall" () -> bool,
	ForceInterleavedReprojectionOn: proc "stdcall" (bOverride: bool),
	ForceReconnectProcess: proc "stdcall" (),
	SuspendRendering: proc "stdcall" (bSuspend: bool),
	GetMirrorTextureD3D11: proc "stdcall" (eEye: Eye, pD3D11DeviceOrResource: rawptr, ppD3D11ShaderResourceView: ^rawptr) -> CompositorError,
	ReleaseMirrorTextureD3D11: proc "stdcall" (pD3D11ShaderResourceView: rawptr),
	GetMirrorTextureGL: proc "stdcall" (eEye: Eye, pglTextureId: ^glUInt, pglSharedTextureHandle: ^glSharedTextureHandle) -> CompositorError,
	ReleaseSharedGLTexture: proc "stdcall" (glTextureId: glUInt, glSharedTextureHandle: glSharedTextureHandle) -> bool,
	LockGLSharedTextureForAccess: proc "stdcall" (glSharedTextureHandle: glSharedTextureHandle),
	UnlockGLSharedTextureForAccess: proc "stdcall" (glSharedTextureHandle: glSharedTextureHandle),
	GetVulkanInstanceExtensionsRequired: proc "stdcall" (pchValue: cstring, unBufferSize: u32) -> u32,
	GetVulkanDeviceExtensionsRequired: proc "stdcall" (pPhysicalDevice: vk.PhysicalDevice, pchValue: cstring, unBufferSize: u32) -> u32,
	SetExplicitTimingMode: proc "stdcall" (eTimingMode: CompositorTimingMode),
	SubmitExplicitTimingData: proc "stdcall" () -> CompositorError,
	IsMotionSmoothingEnabled: proc "stdcall" () -> bool,
	IsMotionSmoothingSupported: proc "stdcall" () -> bool,
	IsCurrentSceneFocusAppLoading: proc "stdcall" () -> bool,
	SetStageOverride_Async: proc "stdcall" (pchRenderModelPath: cstring, pTransform: ^HmdMatrix34, pRenderSettings: ^Compositor_StageRenderSettings, nSizeOfRenderSettings: u32) -> CompositorError,
	ClearStageOverride: proc "stdcall" (),
	GetCompositorBenchmarkResults: proc "stdcall" (pBenchmarkResults: ^Compositor_BenchmarkResults, nSizeOfBenchmarkResults: u32) -> bool,
	GetLastPosePredictionIDs: proc "stdcall" (pRenderPosePredictionID: ^u32, pGamePosePredictionID: ^u32) -> CompositorError,
	GetPosesForFrame: proc "stdcall" (unPosePredictionID: u32, pPoseArray: ^TrackedDevicePose, unPoseArrayCount: u32) -> CompositorError,
}

IHeadsetView :: struct {
	SetHeadsetViewSize: proc "stdcall" (nWidth: u32, nHeight: u32),
	GetHeadsetViewSize: proc "stdcall" (pnWidth: ^u32, pnHeight: ^u32),
	SetHeadsetViewMode: proc "stdcall" (eHeadsetViewMode: HeadsetViewMode),
	GetHeadsetViewMode: proc "stdcall" () -> HeadsetViewMode,
	SetHeadsetViewCropped: proc "stdcall" (bCropped: bool),
	GetHeadsetViewCropped: proc "stdcall" () -> bool,
	GetHeadsetViewAspectRatio: proc "stdcall" () -> f32,
	SetHeadsetViewBlendRange: proc "stdcall" (flStartPct: f32, flEndPct: f32),
	GetHeadsetViewBlendRange: proc "stdcall" (pStartPct: ^f32, pEndPct: ^f32),
}

IOverlay :: struct {
	FindOverlay: proc "stdcall" (pchOverlayKey: cstring, pOverlayHandle: ^OverlayHandle) -> OverlayError,
	CreateOverlay: proc "stdcall" (pchOverlayKey: cstring, pchOverlayName: cstring, pOverlayHandle: ^OverlayHandle) -> OverlayError,
	DestroyOverlay: proc "stdcall" (ulOverlayHandle: OverlayHandle) -> OverlayError,
	GetOverlayKey: proc "stdcall" (ulOverlayHandle: OverlayHandle, pchValue: cstring, unBufferSize: u32, pError: ^OverlayError) -> u32,
	GetOverlayName: proc "stdcall" (ulOverlayHandle: OverlayHandle, pchValue: cstring, unBufferSize: u32, pError: ^OverlayError) -> u32,
	SetOverlayName: proc "stdcall" (ulOverlayHandle: OverlayHandle, pchName: cstring) -> OverlayError,
	GetOverlayImageData: proc "stdcall" (ulOverlayHandle: OverlayHandle, pvBuffer: rawptr, unBufferSize: u32, punWidth: ^u32, punHeight: ^u32) -> OverlayError,
	GetOverlayErrorNameFromEnum: proc "stdcall" (error: OverlayError) -> cstring,
	SetOverlayRenderingPid: proc "stdcall" (ulOverlayHandle: OverlayHandle, unPID: u32) -> OverlayError,
	GetOverlayRenderingPid: proc "stdcall" (ulOverlayHandle: OverlayHandle) -> u32,
	SetOverlayFlag: proc "stdcall" (ulOverlayHandle: OverlayHandle, eOverlayFlag: OverlayFlags, bEnabled: bool) -> OverlayError,
	GetOverlayFlag: proc "stdcall" (ulOverlayHandle: OverlayHandle, eOverlayFlag: OverlayFlags, pbEnabled: ^bool) -> OverlayError,
	GetOverlayFlags: proc "stdcall" (ulOverlayHandle: OverlayHandle, pFlags: ^u32) -> OverlayError,
	SetOverlayColor: proc "stdcall" (ulOverlayHandle: OverlayHandle, fRed: f32, fGreen: f32, fBlue: f32) -> OverlayError,
	GetOverlayColor: proc "stdcall" (ulOverlayHandle: OverlayHandle, pfRed: ^f32, pfGreen: ^f32, pfBlue: ^f32) -> OverlayError,
	SetOverlayAlpha: proc "stdcall" (ulOverlayHandle: OverlayHandle, fAlpha: f32) -> OverlayError,
	GetOverlayAlpha: proc "stdcall" (ulOverlayHandle: OverlayHandle, pfAlpha: ^f32) -> OverlayError,
	SetOverlayTexelAspect: proc "stdcall" (ulOverlayHandle: OverlayHandle, fTexelAspect: f32) -> OverlayError,
	GetOverlayTexelAspect: proc "stdcall" (ulOverlayHandle: OverlayHandle, pfTexelAspect: ^f32) -> OverlayError,
	SetOverlaySortOrder: proc "stdcall" (ulOverlayHandle: OverlayHandle, unSortOrder: u32) -> OverlayError,
	GetOverlaySortOrder: proc "stdcall" (ulOverlayHandle: OverlayHandle, punSortOrder: ^u32) -> OverlayError,
	SetOverlayWidthInMeters: proc "stdcall" (ulOverlayHandle: OverlayHandle, fWidthInMeters: f32) -> OverlayError,
	GetOverlayWidthInMeters: proc "stdcall" (ulOverlayHandle: OverlayHandle, pfWidthInMeters: ^f32) -> OverlayError,
	SetOverlayCurvature: proc "stdcall" (ulOverlayHandle: OverlayHandle, fCurvature: f32) -> OverlayError,
	GetOverlayCurvature: proc "stdcall" (ulOverlayHandle: OverlayHandle, pfCurvature: ^f32) -> OverlayError,
	SetOverlayPreCurvePitch: proc "stdcall" (ulOverlayHandle: OverlayHandle, fRadians: f32) -> OverlayError,
	GetOverlayPreCurvePitch: proc "stdcall" (ulOverlayHandle: OverlayHandle, pfRadians: ^f32) -> OverlayError,
	SetOverlayTextureColorSpace: proc "stdcall" (ulOverlayHandle: OverlayHandle, eTextureColorSpace: ColorSpace) -> OverlayError,
	GetOverlayTextureColorSpace: proc "stdcall" (ulOverlayHandle: OverlayHandle, peTextureColorSpace: ^ColorSpace) -> OverlayError,
	SetOverlayTextureBounds: proc "stdcall" (ulOverlayHandle: OverlayHandle, pOverlayTextureBounds: ^TextureBounds) -> OverlayError,
	GetOverlayTextureBounds: proc "stdcall" (ulOverlayHandle: OverlayHandle, pOverlayTextureBounds: ^TextureBounds) -> OverlayError,
	GetOverlayTransformType: proc "stdcall" (ulOverlayHandle: OverlayHandle, peTransformType: ^OverlayTransformType) -> OverlayError,
	SetOverlayTransformAbsolute: proc "stdcall" (ulOverlayHandle: OverlayHandle, eTrackingOrigin: TrackingUniverseOrigin, pmatTrackingOriginToOverlayTransform: ^HmdMatrix34) -> OverlayError,
	GetOverlayTransformAbsolute: proc "stdcall" (ulOverlayHandle: OverlayHandle, peTrackingOrigin: ^TrackingUniverseOrigin, pmatTrackingOriginToOverlayTransform: ^HmdMatrix34) -> OverlayError,
	SetOverlayTransformTrackedDeviceRelative: proc "stdcall" (ulOverlayHandle: OverlayHandle, unTrackedDevice: TrackedDeviceIndex, pmatTrackedDeviceToOverlayTransform: ^HmdMatrix34) -> OverlayError,
	GetOverlayTransformTrackedDeviceRelative: proc "stdcall" (ulOverlayHandle: OverlayHandle, punTrackedDevice: ^TrackedDeviceIndex, pmatTrackedDeviceToOverlayTransform: ^HmdMatrix34) -> OverlayError,
	SetOverlayTransformTrackedDeviceComponent: proc "stdcall" (ulOverlayHandle: OverlayHandle, unDeviceIndex: TrackedDeviceIndex, pchComponentName: cstring) -> OverlayError,
	GetOverlayTransformTrackedDeviceComponent: proc "stdcall" (ulOverlayHandle: OverlayHandle, punDeviceIndex: ^TrackedDeviceIndex, pchComponentName: cstring, unComponentNameSize: u32) -> OverlayError,
	GetOverlayTransformOverlayRelative: proc "stdcall" (ulOverlayHandle: OverlayHandle, ulOverlayHandleParent: ^OverlayHandle, pmatParentOverlayToOverlayTransform: ^HmdMatrix34) -> OverlayError,
	SetOverlayTransformOverlayRelative: proc "stdcall" (ulOverlayHandle: OverlayHandle, ulOverlayHandleParent: OverlayHandle, pmatParentOverlayToOverlayTransform: ^HmdMatrix34) -> OverlayError,
	SetOverlayTransformCursor: proc "stdcall" (ulCursorOverlayHandle: OverlayHandle, pvHotspot: ^HmdVector2) -> OverlayError,
	GetOverlayTransformCursor: proc "stdcall" (ulOverlayHandle: OverlayHandle, pvHotspot: ^HmdVector2) -> OverlayError,
	SetOverlayTransformProjection: proc "stdcall" (ulOverlayHandle: OverlayHandle, eTrackingOrigin: TrackingUniverseOrigin, pmatTrackingOriginToOverlayTransform: ^HmdMatrix34, pProjection: ^OverlayProjection, eEye: Eye) -> OverlayError,
	ShowOverlay: proc "stdcall" (ulOverlayHandle: OverlayHandle) -> OverlayError,
	HideOverlay: proc "stdcall" (ulOverlayHandle: OverlayHandle) -> OverlayError,
	IsOverlayVisible: proc "stdcall" (ulOverlayHandle: OverlayHandle) -> bool,
	GetTransformForOverlayCoordinates: proc "stdcall" (ulOverlayHandle: OverlayHandle, eTrackingOrigin: TrackingUniverseOrigin, coordinatesInOverlay: HmdVector2, pmatTransform: ^HmdMatrix34) -> OverlayError,
	WaitFrameSync: proc "stdcall" (nTimeoutMs: u32) -> OverlayError,
	PollNextOverlayEvent: proc "stdcall" (ulOverlayHandle: OverlayHandle, pEvent: ^Event, uncbVREvent: u32) -> bool,
	GetOverlayInputMethod: proc "stdcall" (ulOverlayHandle: OverlayHandle, peInputMethod: ^OverlayInputMethod) -> OverlayError,
	SetOverlayInputMethod: proc "stdcall" (ulOverlayHandle: OverlayHandle, eInputMethod: OverlayInputMethod) -> OverlayError,
	GetOverlayMouseScale: proc "stdcall" (ulOverlayHandle: OverlayHandle, pvecMouseScale: ^HmdVector2) -> OverlayError,
	SetOverlayMouseScale: proc "stdcall" (ulOverlayHandle: OverlayHandle, pvecMouseScale: ^HmdVector2) -> OverlayError,
	ComputeOverlayIntersection: proc "stdcall" (ulOverlayHandle: OverlayHandle, pParams: ^OverlayIntersectionParams, pResults: ^OverlayIntersectionResults) -> bool,
	IsHoverTargetOverlay: proc "stdcall" (ulOverlayHandle: OverlayHandle) -> bool,
	SetOverlayIntersectionMask: proc "stdcall" (ulOverlayHandle: OverlayHandle, pMaskPrimitives: ^OverlayIntersectionMaskPrimitive, unNumMaskPrimitives: u32, unPrimitiveSize: u32) -> OverlayError,
	TriggerLaserMouseHapticVibration: proc "stdcall" (ulOverlayHandle: OverlayHandle, fDurationSeconds: f32, fFrequency: f32, fAmplitude: f32) -> OverlayError,
	SetOverlayCursor: proc "stdcall" (ulOverlayHandle: OverlayHandle, ulCursorHandle: OverlayHandle) -> OverlayError,
	SetOverlayCursorPositionOverride: proc "stdcall" (ulOverlayHandle: OverlayHandle, pvCursor: ^HmdVector2) -> OverlayError,
	ClearOverlayCursorPositionOverride: proc "stdcall" (ulOverlayHandle: OverlayHandle) -> OverlayError,
	SetOverlayTexture: proc "stdcall" (ulOverlayHandle: OverlayHandle, pTexture: ^Texture) -> OverlayError,
	ClearOverlayTexture: proc "stdcall" (ulOverlayHandle: OverlayHandle) -> OverlayError,
	SetOverlayRaw: proc "stdcall" (ulOverlayHandle: OverlayHandle, pvBuffer: rawptr, unWidth: u32, unHeight: u32, unBytesPerPixel: u32) -> OverlayError,
	SetOverlayFromFile: proc "stdcall" (ulOverlayHandle: OverlayHandle, pchFilePath: cstring) -> OverlayError,
	GetOverlayTexture: proc "stdcall" (ulOverlayHandle: OverlayHandle, pNativeTextureHandle: ^rawptr, pNativeTextureRef: rawptr, pWidth: ^u32, pHeight: ^u32, pNativeFormat: ^u32, pAPIType: ^TextureType, pColorSpace: ^ColorSpace, pTextureBounds: ^TextureBounds) -> OverlayError,
	ReleaseNativeOverlayHandle: proc "stdcall" (ulOverlayHandle: OverlayHandle, pNativeTextureHandle: rawptr) -> OverlayError,
	GetOverlayTextureSize: proc "stdcall" (ulOverlayHandle: OverlayHandle, pWidth: ^u32, pHeight: ^u32) -> OverlayError,
	CreateDashboardOverlay: proc "stdcall" (pchOverlayKey: cstring, pchOverlayFriendlyName: cstring, pMainHandle: ^OverlayHandle, pThumbnailHandle: ^OverlayHandle) -> OverlayError,
	IsDashboardVisible: proc "stdcall" () -> bool,
	IsActiveDashboardOverlay: proc "stdcall" (ulOverlayHandle: OverlayHandle) -> bool,
	SetDashboardOverlaySceneProcess: proc "stdcall" (ulOverlayHandle: OverlayHandle, unProcessId: u32) -> OverlayError,
	GetDashboardOverlaySceneProcess: proc "stdcall" (ulOverlayHandle: OverlayHandle, punProcessId: ^u32) -> OverlayError,
	ShowDashboard: proc "stdcall" (pchOverlayToShow: cstring),
	GetPrimaryDashboardDevice: proc "stdcall" () -> TrackedDeviceIndex,
	ShowKeyboard: proc "stdcall" (eInputMode: GamepadTextInputMode, eLineInputMode: GamepadTextInputLineMode, unFlags: u32, pchDescription: cstring, unCharMax: u32, pchExistingText: cstring, uUserValue: u64) -> OverlayError,
	ShowKeyboardForOverlay: proc "stdcall" (ulOverlayHandle: OverlayHandle, eInputMode: GamepadTextInputMode, eLineInputMode: GamepadTextInputLineMode, unFlags: u32, pchDescription: cstring, unCharMax: u32, pchExistingText: cstring, uUserValue: u64) -> OverlayError,
	GetKeyboardText: proc "stdcall" (pchText: cstring, cchText: u32) -> u32,
	HideKeyboard: proc "stdcall" (),
	SetKeyboardTransformAbsolute: proc "stdcall" (eTrackingOrigin: TrackingUniverseOrigin, pmatTrackingOriginToKeyboardTransform: ^HmdMatrix34),
	SetKeyboardPositionForOverlay: proc "stdcall" (ulOverlayHandle: OverlayHandle, avoidRect: HmdRect2),
	ShowMessageOverlay: proc "stdcall" (pchText: cstring, pchCaption: cstring, pchButton0Text: cstring, pchButton1Text: cstring, pchButton2Text: cstring, pchButton3Text: cstring) -> MessageOverlayResponse,
	CloseMessageOverlay: proc "stdcall" (),
}

IOverlayView :: struct {
	AcquireOverlayView: proc "stdcall" (ulOverlayHandle: OverlayHandle, pNativeDevice: ^NativeDevice, pOverlayView: ^OverlayView, unOverlayViewSize: u32) -> OverlayError,
	ReleaseOverlayView: proc "stdcall" (pOverlayView: ^OverlayView) -> OverlayError,
	PostOverlayEvent: proc "stdcall" (ulOverlayHandle: OverlayHandle, pvrEvent: ^Event),
	IsViewingPermitted: proc "stdcall" (ulOverlayHandle: OverlayHandle) -> bool,
}

IResources :: struct {
	LoadSharedResource: proc "stdcall" (pchResourceName: cstring, pchBuffer: cstring, unBufferLen: u32) -> u32,
	GetResourceFullPath: proc "stdcall" (pchResourceName: cstring, pchResourceTypeDirectory: cstring, pchPathBuffer: cstring, unBufferLen: u32) -> u32,
}

IRenderModels :: struct {
	LoadRenderModel_Async: proc "stdcall" (pchRenderModelName: cstring, ppRenderModel: ^^RenderModel) -> RenderModelError,
	FreeRenderModel: proc "stdcall" (pRenderModel: ^RenderModel),
	LoadTexture_Async: proc "stdcall" (textureId: TextureID, ppTexture: ^^RenderModel_TextureMap) -> RenderModelError,
	FreeTexture: proc "stdcall" (pTexture: ^RenderModel_TextureMap),
	LoadTextureD3D11_Async: proc "stdcall" (textureId: TextureID, pD3D11Device: rawptr, ppD3D11Texture2D: ^rawptr) -> RenderModelError,
	LoadIntoTextureD3D11_Async: proc "stdcall" (textureId: TextureID, pDstTexture: rawptr) -> RenderModelError,
	FreeTextureD3D11: proc "stdcall" (pD3D11Texture2D: rawptr),
	GetRenderModelName: proc "stdcall" (unRenderModelIndex: u32, pchRenderModelName: cstring, unRenderModelNameLen: u32) -> u32,
	GetRenderModelCount: proc "stdcall" () -> u32,
	GetComponentCount: proc "stdcall" (pchRenderModelName: cstring) -> u32,
	GetComponentName: proc "stdcall" (pchRenderModelName: cstring, unComponentIndex: u32, pchComponentName: cstring, unComponentNameLen: u32) -> u32,
	GetComponentButtonMask: proc "stdcall" (pchRenderModelName: cstring, pchComponentName: cstring) -> u64,
	GetComponentRenderModelName: proc "stdcall" (pchRenderModelName: cstring, pchComponentName: cstring, pchComponentRenderModelName: cstring, unComponentRenderModelNameLen: u32) -> u32,
	GetComponentStateForDevicePath: proc "stdcall" (pchRenderModelName: cstring, pchComponentName: cstring, devicePath: InputValueHandle, pState: ^RenderModel_ControllerMode_State, pComponentState: ^RenderModel_ComponentState) -> bool,
	GetComponentState: proc "stdcall" (pchRenderModelName: cstring, pchComponentName: cstring, pControllerState: ^ControllerState, pState: ^RenderModel_ControllerMode_State, pComponentState: ^RenderModel_ComponentState) -> bool,
	RenderModelHasComponent: proc "stdcall" (pchRenderModelName: cstring, pchComponentName: cstring) -> bool,
	GetRenderModelThumbnailURL: proc "stdcall" (pchRenderModelName: cstring, pchThumbnailURL: cstring, unThumbnailURLLen: u32, peError: ^RenderModelError) -> u32,
	GetRenderModelOriginalPath: proc "stdcall" (pchRenderModelName: cstring, pchOriginalPath: cstring, unOriginalPathLen: u32, peError: ^RenderModelError) -> u32,
	GetRenderModelErrorNameFromEnum: proc "stdcall" (error: RenderModelError) -> cstring,
}

IExtendedDisplay :: struct {
	GetWindowBounds: proc "stdcall" (pnX: ^i32, pnY: ^i32, pnWidth: ^u32, pnHeight: ^u32),
	GetEyeOutputViewport: proc "stdcall" (eEye: Eye, pnX: ^u32, pnY: ^u32, pnWidth: ^u32, pnHeight: ^u32),
	GetDXGIOutputInfo: proc "stdcall" (pnAdapterIndex: ^i32, pnAdapterOutputIndex: ^i32),
}

ISettings :: struct {
	GetSettingsErrorNameFromEnum: proc "stdcall" (eError: SettingsError) -> cstring,
	SetBool: proc "stdcall" (pchSection: cstring, pchSettingsKey: cstring, bValue: bool, peError: ^SettingsError),
	SetInt32: proc "stdcall" (pchSection: cstring, pchSettingsKey: cstring, nValue: i32, peError: ^SettingsError),
	SetFloat: proc "stdcall" (pchSection: cstring, pchSettingsKey: cstring, flValue: f32, peError: ^SettingsError),
	SetString: proc "stdcall" (pchSection: cstring, pchSettingsKey: cstring, pchValue: cstring, peError: ^SettingsError),
	GetBool: proc "stdcall" (pchSection: cstring, pchSettingsKey: cstring, peError: ^SettingsError) -> bool,
	GetInt32: proc "stdcall" (pchSection: cstring, pchSettingsKey: cstring, peError: ^SettingsError) -> i32,
	GetFloat: proc "stdcall" (pchSection: cstring, pchSettingsKey: cstring, peError: ^SettingsError) -> f32,
	GetString: proc "stdcall" (pchSection: cstring, pchSettingsKey: cstring, pchValue: cstring, unValueLen: u32, peError: ^SettingsError),
	RemoveSection: proc "stdcall" (pchSection: cstring, peError: ^SettingsError),
	RemoveKeyInSection: proc "stdcall" (pchSection: cstring, pchSettingsKey: cstring, peError: ^SettingsError),
}

IApplications :: struct {
	AddApplicationManifest: proc "stdcall" (pchApplicationManifestFullPath: cstring, bTemporary: bool) -> ApplicationError,
	RemoveApplicationManifest: proc "stdcall" (pchApplicationManifestFullPath: cstring) -> ApplicationError,
	IsApplicationInstalled: proc "stdcall" (pchAppKey: cstring) -> bool,
	GetApplicationCount: proc "stdcall" () -> u32,
	GetApplicationKeyByIndex: proc "stdcall" (unApplicationIndex: u32, pchAppKeyBuffer: cstring, unAppKeyBufferLen: u32) -> ApplicationError,
	GetApplicationKeyByProcessId: proc "stdcall" (unProcessId: u32, pchAppKeyBuffer: cstring, unAppKeyBufferLen: u32) -> ApplicationError,
	LaunchApplication: proc "stdcall" (pchAppKey: cstring) -> ApplicationError,
	LaunchTemplateApplication: proc "stdcall" (pchTemplateAppKey: cstring, pchNewAppKey: cstring, pKeys: ^AppOverrideKeys, unKeys: u32) -> ApplicationError,
	LaunchApplicationFromMimeType: proc "stdcall" (pchMimeType: cstring, pchArgs: cstring) -> ApplicationError,
	LaunchDashboardOverlay: proc "stdcall" (pchAppKey: cstring) -> ApplicationError,
	CancelApplicationLaunch: proc "stdcall" (pchAppKey: cstring) -> bool,
	IdentifyApplication: proc "stdcall" (unProcessId: u32, pchAppKey: cstring) -> ApplicationError,
	GetApplicationProcessId: proc "stdcall" (pchAppKey: cstring) -> u32,
	GetApplicationsErrorNameFromEnum: proc "stdcall" (error: ApplicationError) -> cstring,
	GetApplicationPropertyString: proc "stdcall" (pchAppKey: cstring, eProperty: ApplicationProperty, pchPropertyValueBuffer: cstring, unPropertyValueBufferLen: u32, peError: ^ApplicationError) -> u32,
	GetApplicationPropertyBool: proc "stdcall" (pchAppKey: cstring, eProperty: ApplicationProperty, peError: ^ApplicationError) -> bool,
	GetApplicationPropertyUint64: proc "stdcall" (pchAppKey: cstring, eProperty: ApplicationProperty, peError: ^ApplicationError) -> u64,
	SetApplicationAutoLaunch: proc "stdcall" (pchAppKey: cstring, bAutoLaunch: bool) -> ApplicationError,
	GetApplicationAutoLaunch: proc "stdcall" (pchAppKey: cstring) -> bool,
	SetDefaultApplicationForMimeType: proc "stdcall" (pchAppKey: cstring, pchMimeType: cstring) -> ApplicationError,
	GetDefaultApplicationForMimeType: proc "stdcall" (pchMimeType: cstring, pchAppKeyBuffer: cstring, unAppKeyBufferLen: u32) -> bool,
	GetApplicationSupportedMimeTypes: proc "stdcall" (pchAppKey: cstring, pchMimeTypesBuffer: cstring, unMimeTypesBuffer: u32) -> bool,
	GetApplicationsThatSupportMimeType: proc "stdcall" (pchMimeType: cstring, pchAppKeysThatSupportBuffer: cstring, unAppKeysThatSupportBuffer: u32) -> u32,
	GetApplicationLaunchArguments: proc "stdcall" (unHandle: u32, pchArgs: cstring, unArgs: u32) -> u32,
	GetStartingApplication: proc "stdcall" (pchAppKeyBuffer: cstring, unAppKeyBufferLen: u32) -> ApplicationError,
	GetSceneApplicationState: proc "stdcall" () -> SceneApplicationState,
	PerformApplicationPrelaunchCheck: proc "stdcall" (pchAppKey: cstring) -> ApplicationError,
	GetSceneApplicationStateNameFromEnum: proc "stdcall" (state: SceneApplicationState) -> cstring,
	LaunchInternalProcess: proc "stdcall" (pchBinaryPath: cstring, pchArguments: cstring, pchWorkingDirectory: cstring) -> ApplicationError,
	GetCurrentSceneProcessId: proc "stdcall" () -> u32,
}

ITrackedCamera :: struct {
	GetCameraErrorNameFromEnum: proc "stdcall" (eCameraError: TrackedCameraError) -> cstring,
	HasCamera: proc "stdcall" (nDeviceIndex: TrackedDeviceIndex, pHasCamera: ^bool) -> TrackedCameraError,
	GetCameraFrameSize: proc "stdcall" (nDeviceIndex: TrackedDeviceIndex, eFrameType: TrackedCameraFrameType, pnWidth: ^u32, pnHeight: ^u32, pnFrameBufferSize: ^u32) -> TrackedCameraError,
	GetCameraIntrinsics: proc "stdcall" (nDeviceIndex: TrackedDeviceIndex, nCameraIndex: u32, eFrameType: TrackedCameraFrameType, pFocalLength: ^HmdVector2, pCenter: ^HmdVector2) -> TrackedCameraError,
	GetCameraProjection: proc "stdcall" (nDeviceIndex: TrackedDeviceIndex, nCameraIndex: u32, eFrameType: TrackedCameraFrameType, flZNear: f32, flZFar: f32, pProjection: ^HmdMatrix44) -> TrackedCameraError,
	AcquireVideoStreamingService: proc "stdcall" (nDeviceIndex: TrackedDeviceIndex, pHandle: ^TrackedCameraHandle) -> TrackedCameraError,
	ReleaseVideoStreamingService: proc "stdcall" (hTrackedCamera: TrackedCameraHandle) -> TrackedCameraError,
	GetVideoStreamFrameBuffer: proc "stdcall" (hTrackedCamera: TrackedCameraHandle, eFrameType: TrackedCameraFrameType, pFrameBuffer: rawptr, nFrameBufferSize: u32, pFrameHeader: ^CameraVideoStreamFrameHeader, nFrameHeaderSize: u32) -> TrackedCameraError,
	GetVideoStreamTextureSize: proc "stdcall" (nDeviceIndex: TrackedDeviceIndex, eFrameType: TrackedCameraFrameType, pTextureBounds: ^TextureBounds, pnWidth: ^u32, pnHeight: ^u32) -> TrackedCameraError,
	GetVideoStreamTextureD3D11: proc "stdcall" (hTrackedCamera: TrackedCameraHandle, eFrameType: TrackedCameraFrameType, pD3D11DeviceOrResource: rawptr, ppD3D11ShaderResourceView: ^rawptr, pFrameHeader: ^CameraVideoStreamFrameHeader, nFrameHeaderSize: u32) -> TrackedCameraError,
	GetVideoStreamTextureGL: proc "stdcall" (hTrackedCamera: TrackedCameraHandle, eFrameType: TrackedCameraFrameType, pglTextureId: ^glUInt, pFrameHeader: ^CameraVideoStreamFrameHeader, nFrameHeaderSize: u32) -> TrackedCameraError,
	ReleaseVideoStreamTextureGL: proc "stdcall" (hTrackedCamera: TrackedCameraHandle, glTextureId: glUInt) -> TrackedCameraError,
	SetCameraTrackingSpace: proc "stdcall" (eUniverse: TrackingUniverseOrigin),
	GetCameraTrackingSpace: proc "stdcall" () -> TrackingUniverseOrigin,
}

IScreenshots :: struct {
	RequestScreenshot: proc "stdcall" (pOutScreenshotHandle: ^ScreenshotHandle, type: ScreenshotType, pchPreviewFilename: cstring, pchVRFilename: cstring) -> ScreenshotError,
	HookScreenshot: proc "stdcall" (pSupportedTypes: ^ScreenshotType, numTypes: int) -> ScreenshotError,
	GetScreenshotPropertyType: proc "stdcall" (screenshotHandle: ScreenshotHandle, pError: ^ScreenshotError) -> ScreenshotType,
	GetScreenshotPropertyFilename: proc "stdcall" (screenshotHandle: ScreenshotHandle, filenameType: ScreenshotPropertyFilenames, pchFilename: cstring, cchFilename: u32, pError: ^ScreenshotError) -> u32,
	UpdateScreenshotProgress: proc "stdcall" (screenshotHandle: ScreenshotHandle, flProgress: f32) -> ScreenshotError,
	TakeStereoScreenshot: proc "stdcall" (pOutScreenshotHandle: ^ScreenshotHandle, pchPreviewFilename: cstring, pchVRFilename: cstring) -> ScreenshotError,
	SubmitScreenshot: proc "stdcall" (screenshotHandle: ScreenshotHandle, type: ScreenshotType, pchSourcePreviewFilename: cstring, pchSourceVRFilename: cstring) -> ScreenshotError,
}

IDriverManager :: struct {
	GetDriverCount: proc "stdcall" () -> u32,
	GetDriverName: proc "stdcall" (nDriver: DriverId, pchValue: cstring, unBufferSize: u32) -> u32,
	GetDriverHandle: proc "stdcall" (pchDriverName: cstring) -> DriverHandle,
	IsEnabled: proc "stdcall" (nDriver: DriverId) -> bool,
}

IInput :: struct {
	SetActionManifestPath: proc "stdcall" (pchActionManifestPath: cstring) -> InputError,
	GetActionSetHandle: proc "stdcall" (pchActionSetName: cstring, pHandle: ^ActionSetHandle) -> InputError,
	GetActionHandle: proc "stdcall" (pchActionName: cstring, pHandle: ^ActionHandle) -> InputError,
	GetInputSourceHandle: proc "stdcall" (pchInputSourcePath: cstring, pHandle: ^InputValueHandle) -> InputError,
	UpdateActionState: proc "stdcall" (pSets: ^ActiveActionSet, unSizeOfVRSelectedActionSet_t: u32, unSetCount: u32) -> InputError,
	GetDigitalActionData: proc "stdcall" (action: ActionHandle, pActionData: ^InputDigitalActionData, unActionDataSize: u32, ulRestrictToDevice: InputValueHandle) -> InputError,
	GetAnalogActionData: proc "stdcall" (action: ActionHandle, pActionData: ^InputAnalogActionData, unActionDataSize: u32, ulRestrictToDevice: InputValueHandle) -> InputError,
	GetPoseActionDataRelativeToNow: proc "stdcall" (action: ActionHandle, eOrigin: TrackingUniverseOrigin, fPredictedSecondsFromNow: f32, pActionData: ^InputPoseActionData, unActionDataSize: u32, ulRestrictToDevice: InputValueHandle) -> InputError,
	GetPoseActionDataForNextFrame: proc "stdcall" (action: ActionHandle, eOrigin: TrackingUniverseOrigin, pActionData: ^InputPoseActionData, unActionDataSize: u32, ulRestrictToDevice: InputValueHandle) -> InputError,
	GetSkeletalActionData: proc "stdcall" (action: ActionHandle, pActionData: ^InputSkeletalActionData, unActionDataSize: u32) -> InputError,
	GetDominantHand: proc "stdcall" (peDominantHand: ^TrackedControllerRole) -> InputError,
	SetDominantHand: proc "stdcall" (eDominantHand: TrackedControllerRole) -> InputError,
	GetBoneCount: proc "stdcall" (action: ActionHandle, pBoneCount: ^u32) -> InputError,
	GetBoneHierarchy: proc "stdcall" (action: ActionHandle, pParentIndices: ^BoneIndex, unIndexArayCount: u32) -> InputError,
	GetBoneName: proc "stdcall" (action: ActionHandle, nBoneIndex: BoneIndex, pchBoneName: cstring, unNameBufferSize: u32) -> InputError,
	GetSkeletalReferenceTransforms: proc "stdcall" (action: ActionHandle, eTransformSpace: SkeletalTransformSpace, eReferencePose: SkeletalReferencePose, pTransformArray: ^BoneTransform, unTransformArrayCount: u32) -> InputError,
	GetSkeletalTrackingLevel: proc "stdcall" (action: ActionHandle, pSkeletalTrackingLevel: ^SkeletalTrackingLevel) -> InputError,
	GetSkeletalBoneData: proc "stdcall" (action: ActionHandle, eTransformSpace: SkeletalTransformSpace, eMotionRange: SkeletalMotionRange, pTransformArray: ^BoneTransform, unTransformArrayCount: u32) -> InputError,
	GetSkeletalSummaryData: proc "stdcall" (action: ActionHandle, eSummaryType: SummaryType, pSkeletalSummaryData: ^SkeletalSummaryData) -> InputError,
	GetSkeletalBoneDataCompressed: proc "stdcall" (action: ActionHandle, eMotionRange: SkeletalMotionRange, pvCompressedData: rawptr, unCompressedSize: u32, punRequiredCompressedSize: ^u32) -> InputError,
	DecompressSkeletalBoneData: proc "stdcall" (pvCompressedBuffer: rawptr, unCompressedBufferSize: u32, eTransformSpace: SkeletalTransformSpace, pTransformArray: ^BoneTransform, unTransformArrayCount: u32) -> InputError,
	TriggerHapticVibrationAction: proc "stdcall" (action: ActionHandle, fStartSecondsFromNow: f32, fDurationSeconds: f32, fFrequency: f32, fAmplitude: f32, ulRestrictToDevice: InputValueHandle) -> InputError,
	GetActionOrigins: proc "stdcall" (actionSetHandle: ActionSetHandle, digitalActionHandle: ActionHandle, originsOut: ^InputValueHandle, originOutCount: u32) -> InputError,
	GetOriginLocalizedName: proc "stdcall" (origin: InputValueHandle, pchNameArray: cstring, unNameArraySize: u32, unStringSectionsToInclude: i32) -> InputError,
	GetOriginTrackedDeviceInfo: proc "stdcall" (origin: InputValueHandle, pOriginInfo: ^InputOriginInfo, unOriginInfoSize: u32) -> InputError,
	GetActionBindingInfo: proc "stdcall" (action: ActionHandle, pOriginInfo: ^InputBindingInfo, unBindingInfoSize: u32, unBindingInfoCount: u32, punReturnedBindingInfoCount: ^u32) -> InputError,
	ShowActionOrigins: proc "stdcall" (actionSetHandle: ActionSetHandle, ulActionHandle: ActionHandle) -> InputError,
	ShowBindingsForActionSet: proc "stdcall" (pSets: ^ActiveActionSet, unSizeOfVRSelectedActionSet_t: u32, unSetCount: u32, originToHighlight: InputValueHandle) -> InputError,
	GetComponentStateForBinding: proc "stdcall" (pchRenderModelName: cstring, pchComponentName: cstring, pOriginInfo: ^InputBindingInfo, unBindingInfoSize: u32, unBindingInfoCount: u32, pComponentState: ^RenderModel_ComponentState) -> InputError,
	IsUsingLegacyInput: proc "stdcall" () -> bool,
	OpenBindingUI: proc "stdcall" (pchAppKey: cstring, ulActionSetHandle: ActionSetHandle, ulDeviceHandle: InputValueHandle, bShowOnDesktop: bool) -> InputError,
	GetBindingVariant: proc "stdcall" (ulDevicePath: InputValueHandle, pchVariantArray: cstring, unVariantArraySize: u32) -> InputError,
}

IIOBuffer :: struct {
	Open: proc "stdcall" (pchPath: cstring, mode: IOBufferMode, unElementSize: u32, unElements: u32, pulBuffer: ^IOBufferHandle) -> IOBufferError,
	Close: proc "stdcall" (ulBuffer: IOBufferHandle) -> IOBufferError,
	Read: proc "stdcall" (ulBuffer: IOBufferHandle, pDst: rawptr, unBytes: u32, punRead: ^u32) -> IOBufferError,
	Write: proc "stdcall" (ulBuffer: IOBufferHandle, pSrc: rawptr, unBytes: u32) -> IOBufferError,
	PropertyContainer: proc "stdcall" (ulBuffer: IOBufferHandle) -> PropertyContainerHandle,
	HasReaders: proc "stdcall" (ulBuffer: IOBufferHandle) -> bool,
}

ISpatialAnchors :: struct {
	CreateSpatialAnchorFromDescriptor: proc "stdcall" (pchDescriptor: cstring, pHandleOut: ^SpatialAnchorHandle) -> SpatialAnchorError,
	CreateSpatialAnchorFromPose: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex, eOrigin: TrackingUniverseOrigin, pPose: ^SpatialAnchorPose, pHandleOut: ^SpatialAnchorHandle) -> SpatialAnchorError,
	GetSpatialAnchorPose: proc "stdcall" (unHandle: SpatialAnchorHandle, eOrigin: TrackingUniverseOrigin, pPoseOut: ^SpatialAnchorPose) -> SpatialAnchorError,
	GetSpatialAnchorDescriptor: proc "stdcall" (unHandle: SpatialAnchorHandle, pchDescriptorOut: cstring, punDescriptorBufferLenInOut: ^u32) -> SpatialAnchorError,
}

IDebug :: struct {
	EmitVrProfilerEvent: proc "stdcall" (pchMessage: cstring) -> DebugError,
	BeginVrProfilerEvent: proc "stdcall" (pHandleOut: ^VrProfilerEventHandle) -> DebugError,
	FinishVrProfilerEvent: proc "stdcall" (hHandle: VrProfilerEventHandle, pchMessage: cstring) -> DebugError,
	DriverDebugRequest: proc "stdcall" (unDeviceIndex: TrackedDeviceIndex, pchRequest: cstring, pchResponseBuffer: cstring, unResponseBufferSize: u32) -> u32,
}

INotifications :: struct {
	CreateNotification: proc "stdcall" (ulOverlayHandle: OverlayHandle, ulUserValue: u64, type: NotificationType, pchText: cstring, style: NotificationStyle, pImage: ^NotificationBitmap, pNotificationId: ^NotificationId) -> NotificationError,
	RemoveNotification: proc "stdcall" (notificationId: NotificationId) -> NotificationError,
}

IProperties :: struct {
	ReadPropertyBatch: proc "stdcall" (ulContainerHandle: PropertyContainerHandle, pBatch: ^PropertyRead, unBatchEntryCount: u32) -> TrackedPropertyError,
	WritePropertyBatch: proc "stdcall" (ulContainerHandle: PropertyContainerHandle, pBatch: ^PropertyWrite, unBatchEntryCount: u32) -> TrackedPropertyError,
	GetPropErrorNameFromEnum: proc "stdcall" (error: TrackedPropertyError) -> cstring,
	TrackedDeviceToPropertyContainer: proc "stdcall" (nDevice: TrackedDeviceIndex) -> PropertyContainerHandle,
}

IPaths :: struct {
	ReadPathBatch: proc "stdcall" (ulRootHandle: PropertyContainerHandle, pBatch: ^PathRead, unBatchEntryCount: u32) -> TrackedPropertyError,
	WritePathBatch: proc "stdcall" (ulRootHandle: PropertyContainerHandle, pBatch: ^PathWrite, unBatchEntryCount: u32) -> TrackedPropertyError,
	StringToHandle: proc "stdcall" (pHandle: ^PathHandle, pchPath: cstring) -> TrackedPropertyError,
	HandleToString: proc "stdcall" (pHandle: PathHandle, pchBuffer: cstring, unBufferSize: u32, punBufferSizeUsed: ^u32) -> TrackedPropertyError,
}

IBlockQueue :: struct {
	Create: proc "stdcall" (pulQueueHandle: ^PropertyContainerHandle, pchPath: cstring, unBlockDataSize: u32, unBlockHeaderSize: u32, unBlockCount: u32, unFlags: u32) -> BlockQueueError,
	Connect: proc "stdcall" (pulQueueHandle: ^PropertyContainerHandle, pchPath: cstring) -> BlockQueueError,
	Destroy: proc "stdcall" (ulQueueHandle: PropertyContainerHandle) -> BlockQueueError,
	AcquireWriteOnlyBlock: proc "stdcall" (ulQueueHandle: PropertyContainerHandle, pulBlockHandle: ^PropertyContainerHandle, ppvBuffer: ^rawptr) -> BlockQueueError,
	ReleaseWriteOnlyBlock: proc "stdcall" (ulQueueHandle: PropertyContainerHandle, ulBlockHandle: PropertyContainerHandle) -> BlockQueueError,
	WaitAndAcquireReadOnlyBlock: proc "stdcall" (ulQueueHandle: PropertyContainerHandle, pulBlockHandle: ^PropertyContainerHandle, ppvBuffer: ^rawptr, eReadType: BlockQueueReadType, unTimeoutMs: u32) -> BlockQueueError,
	AcquireReadOnlyBlock: proc "stdcall" (ulQueueHandle: PropertyContainerHandle, pulBlockHandle: ^PropertyContainerHandle, ppvBuffer: ^rawptr, eReadType: BlockQueueReadType) -> BlockQueueError,
	ReleaseReadOnlyBlock: proc "stdcall" (ulQueueHandle: PropertyContainerHandle, ulBlockHandle: PropertyContainerHandle) -> BlockQueueError,
	QueueHasReader: proc "stdcall" (ulQueueHandle: PropertyContainerHandle, pbHasReaders: ^bool) -> BlockQueueError,
}

